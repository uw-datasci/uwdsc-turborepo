# Database Setup

Learn how to work with db-mate, postgres.js, and Supabase in this project.

## Overview

Our project uses:

- **postgres.js** - Fast PostgreSQL client optimized for serverless and Supabase Transaction Pooler
- **db-mate** - Database migration tool with SQL files
- **Supabase** - PostgreSQL database and authentication
- **PostgreSQL** - Relational database

## Architecture

```
┌─────────────────────────────────────────┐
│     Application Layer                   │
│  (Next.js API Routes & Services)        │
└───────────┬─────────────────────────────┘
            │
┌───────────▼─────────────────────────────┐
│        postgres.js                       │
│   (Raw SQL queries, tagged templates)   │
└───────────┬─────────────────────────────┘
            │
┌───────────▼─────────────────────────────┐
│     Supabase PostgreSQL                  │
│   (Database & Auth)                      │
└──────────────────────────────────────────┘
```

## Setup

### 1. Environment Variables

Create `.env.local` files in your apps:

```bash
# apps/web/.env.local
DATABASE_URL="postgresql://user:password@host:5432/database"
SUPABASE_URL="https://your-project.supabase.co"
SUPABASE_ANON_KEY="your-anon-key"
SUPABASE_SERVICE_ROLE_KEY="your-service-role-key"
```

### 2. Database Migrations

Migrations are located in:

- `packages/server/web/src/db/migrations/`
- `packages/server/cxc/src/db/migrations/`

**Example migration file** (`001_create_users_table.up.sql`):

```sql
-- packages/server/web/src/db/migrations/001_create_users_table.up.sql

CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  bio TEXT,
  avatar VARCHAR(500),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
```

**Down migration** (`001_create_users_table.down.sql`):

```sql
-- packages/server/web/src/db/migrations/001_create_users_table.down.sql

DROP TABLE IF EXISTS users;
```

## db-mate Workflow

### Install db-mate

```bash
# Install globally
npm install -g db-mate

# Or use npx
npx db-mate
```

### Create Migration

Create a new migration:

```bash
cd packages/server/web
db-mate new add_user_bio
```

This creates two files:
- `001_add_user_bio.up.sql` - Migration to apply
- `001_add_user_bio.down.sql` - Migration to rollback

### Apply Migrations

Apply all pending migrations:

```bash
cd packages/server/web
db-mate up
```

### Rollback Migration

Rollback the last migration:

```bash
cd packages/server/web
db-mate down
```

### Reset Database

**Warning**: This deletes all data!

```bash
cd packages/server/web
db-mate drop
db-mate up
```

### Migration Status

Check which migrations have been applied:

```bash
cd packages/server/web
db-mate status
```

## Using postgres.js

### Connection Setup

```typescript
// packages/server/core/src/database/connection.ts
import postgres from "postgres";

export const sql = postgres(process.env.DATABASE_URL!, {
  // CRITICAL: Required for Supabase Transaction Pooler (port 6543)
  // Transaction pooler doesn't support prepared statements
  prepare: false,

  // Optimized for serverless + Supabase Transaction Pooler
  max: 1, // One connection per serverless function
  idle_timeout: 10, // Seconds before idle connections are closed
  connect_timeout: 10, // Seconds to wait for connection
  max_lifetime: 60 * 30, // 30 minutes

  // Connection options
  connection: { search_path: "public,auth" },

  // Transform options for consistent behavior
  transform: { undefined: null },

  // Error handling
  onnotice: () => {}, // Suppress notices
});
```

### Tagged Template Queries

postgres.js uses tagged template literals for SQL queries, providing automatic escaping and type safety:

```typescript
// packages/server/web/src/repository/userRepository.ts
import { BaseRepository } from "@uwdsc/server/core/repository/baseRepository";

export class UserRepository extends BaseRepository {
  // Find one
  async findById(id: string) {
    const result = await this.sql`
      SELECT * FROM users WHERE id = ${id}
    `;
    return result[0] || null;
  }

  // Find many
  async findAll() {
    const result = await this.sql`
      SELECT * FROM users ORDER BY created_at DESC
    `;
    return result;
  }

  // Create
  async create(data: { email: string; name: string }) {
    const result = await this.sql`
      INSERT INTO users (email, name)
      VALUES (${data.email}, ${data.name})
      RETURNING *
    `;
    return result[0];
  }

  // Update
  async update(id: string, data: { name?: string; bio?: string }) {
    const result = await this.sql`
      UPDATE users
      SET 
        name = ${data.name ?? this.sql`name`},
        bio = ${data.bio ?? this.sql`bio`},
        updated_at = NOW()
      WHERE id = ${id}
      RETURNING *
    `;
    return result[0];
  }

  // Delete
  async delete(id: string) {
    const result = await this.sql`
      DELETE FROM users WHERE id = ${id} RETURNING *
    `;
    return result[0];
  }
}
```

### Relations

```typescript
// Include related data with JOIN
async findUserWithProfile(userId: string) {
  const result = await this.sql`
    SELECT 
      u.*,
      p.bio as profile_bio
    FROM users u
    LEFT JOIN profiles p ON p.user_id = u.id
    WHERE u.id = ${userId}
  `;
  return result[0] || null;
}

// Nested writes (using transactions)
async createUserWithProfile(data: {
  email: string;
  name: string;
  bio: string;
}) {
  return await this.sql.begin(async (sql) => {
    // Create user
    const [user] = await sql`
      INSERT INTO users (email, name)
      VALUES (${data.email}, ${data.name})
      RETURNING *
    `;

    // Create profile
    await sql`
      INSERT INTO profiles (user_id, bio)
      VALUES (${user.id}, ${data.bio})
    `;

    return user;
  });
}
```

### Filtering

```typescript
// Where clause
async findActiveUsers() {
  const result = await this.sql`
    SELECT * FROM users
    WHERE status = ${"active"}
      AND created_at >= ${new Date("2024-01-01")}
  `;
  return result;
}

// OR conditions with LIKE
async search(query: string) {
  const searchTerm = `%${query}%`;
  const result = await this.sql`
    SELECT * FROM users
    WHERE name ILIKE ${searchTerm} OR email ILIKE ${searchTerm}
  `;
  return result;
}
```

### Pagination

```typescript
async findWithPagination(page: number, limit: number) {
  const offset = (page - 1) * limit;

  const [users, countResult] = await Promise.all([
    this.sql`
      SELECT * FROM users
      ORDER BY created_at DESC
      LIMIT ${limit} OFFSET ${offset}
    `,
    this.sql`SELECT COUNT(*) as total FROM users`,
  ]);

  return {
    users,
    total: Number(countResult[0].total),
    page,
    pages: Math.ceil(Number(countResult[0].total) / limit),
  };
}
```

### Transactions

```typescript
async transferCredits(fromId: string, toId: string, amount: number) {
  return await this.sql.begin(async (sql) => {
    // Deduct from sender
    await sql`
      UPDATE users
      SET credits = credits - ${amount}
      WHERE id = ${fromId}
    `;

    // Add to receiver
    await sql`
      UPDATE users
      SET credits = credits + ${amount}
      WHERE id = ${toId}
    `;

    // Create transaction record
    await sql`
      INSERT INTO transactions (from_id, to_id, amount)
      VALUES (${fromId}, ${toId}, ${amount})
    `;
  });
}
```

### Aggregations

```typescript
async getStats() {
  const result = await this.sql`
    SELECT 
      COUNT(*) as total_users,
      AVG(age) as avg_age,
      MIN(created_at) as first_user,
      MAX(created_at) as latest_user
    FROM users
  `;
  return result[0];
}

async groupByStatus() {
  const result = await this.sql`
    SELECT status, COUNT(*) as count
    FROM users
    GROUP BY status
  `;
  return result;
}
```

## Supabase Integration

### Authentication

```typescript
// packages/server/core/src/services/authService.ts
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export class AuthService {
  async signUp(email: string, password: string) {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    });

    if (error) throw error;
    return data;
  }

  async signIn(email: string, password: string) {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (error) throw error;
    return data;
  }

  async getUser(token: string) {
    const { data, error } = await supabase.auth.getUser(token);
    if (error) throw error;
    return data.user;
  }
}
```

### File Storage

```typescript
// packages/server/core/src/services/fileService.ts
export class FileService {
  async uploadFile(bucket: string, path: string, file: File) {
    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(path, file);

    if (error) throw error;
    return data;
  }

  getPublicUrl(bucket: string, path: string) {
    const { data } = supabase.storage.from(bucket).getPublicUrl(path);

    return data.publicUrl;
  }

  async deleteFile(bucket: string, path: string) {
    const { error } = await supabase.storage.from(bucket).remove([path]);

    if (error) throw error;
  }
}
```

## Data Seeding

### Create Seed File

```typescript
// packages/server/web/src/db/seed.ts
import { sql } from "@uwdsc/server/core/database/connection";

async function main() {
  // Clear existing data
  await sql`DELETE FROM applications`;
  await sql`DELETE FROM profiles`;
  await sql`DELETE FROM users`;

  // Create test users
  const [user1] = await sql`
    INSERT INTO users (email, name)
    VALUES (${"john@example.com"}, ${"John Doe"})
    RETURNING *
  `;

  await sql`
    INSERT INTO profiles (user_id, bio)
    VALUES (${user1.id}, ${"Software developer"})
  `;

  const [user2] = await sql`
    INSERT INTO users (email, name)
    VALUES (${"jane@example.com"}, ${"Jane Smith"})
    RETURNING *
  `;

  await sql`
    INSERT INTO profiles (user_id, bio)
    VALUES (${user2.id}, ${"Product designer"})
  `;

  // Create applications
  await sql`
    INSERT INTO applications (user_id, status, data)
    VALUES 
      (${user1.id}, ${"pending"}, ${JSON.stringify({})}),
      (${user2.id}, ${"approved"}, ${JSON.stringify({})})
  `;

  console.log("Database seeded successfully");
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await sql.end();
  });
```

### Run Seed

```bash
cd packages/server/web
tsx src/db/seed.ts
```

## Best Practices

### ✅ Do

- Use tagged template literals for automatic SQL escaping
- Use transactions for multi-step operations with `sql.begin()`
- Handle errors appropriately
- Use TypeScript types for query results
- Index frequently queried columns
- Use SELECT to limit returned fields
- Set `prepare: false` for Supabase Transaction Pooler
- Keep max connections to 1 for serverless functions

### ❌ Don't

- Use string concatenation for SQL queries (SQL injection risk)
- Store large files in database
- Skip migrations in production
- Expose database errors to clients
- Create N+1 queries (use JOINs or batch queries)
- Enable prepared statements with Supabase Transaction Pooler

## Common Patterns

### Repository Pattern

```typescript
import { BaseRepository } from "@uwdsc/server/core/repository/baseRepository";

export class UserRepository extends BaseRepository {
  async findByEmail(email: string) {
    const result = await this.sql`
      SELECT * FROM users WHERE email = ${email}
    `;
    return result[0] || null;
  }

  async existsByEmail(email: string): Promise<boolean> {
    const result = await this.sql`
      SELECT COUNT(*) as count FROM users WHERE email = ${email}
    `;
    return Number(result[0].count) > 0;
  }
}
```

### Soft Deletes

```sql
-- Migration
ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP;
CREATE INDEX idx_users_deleted_at ON users(deleted_at);
```

```typescript
async softDelete(id: string) {
  const result = await this.sql`
    UPDATE users
    SET deleted_at = NOW()
    WHERE id = ${id}
    RETURNING *
  `;
  return result[0];
}

async findActive() {
  const result = await this.sql`
    SELECT * FROM users WHERE deleted_at IS NULL
  `;
  return result;
}
```

### Optimistic Locking

```sql
-- Migration
ALTER TABLE users ADD COLUMN version INTEGER DEFAULT 0;
```

```typescript
async updateWithVersion(
  id: string,
  currentVersion: number,
  data: any
) {
  const result = await this.sql`
    UPDATE users
    SET name = ${data.name}, version = version + 1
    WHERE id = ${id} AND version = ${currentVersion}
    RETURNING *
  `;
  return result[0];
}
```

## Troubleshooting

### Connection Issues

Check environment variables and database connectivity:

```typescript
import { sql } from "@uwdsc/server/core/database/connection";

async function testConnection() {
  try {
    await sql`SELECT 1`;
    console.log("Database connected");
  } catch (error) {
    console.error("Database connection failed:", error);
  }
}
```

### Timeout Issues

If you experience connection timeouts with Supabase:

- Ensure `prepare: false` is set in connection options
- Use port 6543 for Transaction Pooler mode
- Keep `max: 1` for serverless environments
- Verify `DATABASE_URL` uses transaction pooler endpoint

### Migration Issues

```bash
# Check migration status
db-mate status

# Force rollback if needed
db-mate down --force

# Re-apply migrations
db-mate up
```

### Query Performance

Use EXPLAIN ANALYZE to debug slow queries:

```sql
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'test@example.com';
```

## Resources

- [postgres.js Documentation](https://github.com/porsager/postgres)
- [db-mate Documentation](https://github.com/amacneil/dbmate)
- [Supabase Documentation](https://supabase.com/docs)
- [Supabase Transaction Pooler Guide](https://supabase.com/docs/guides/database/connecting-to-postgres#connection-pooler)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)

## Next Steps

- [Creating API Endpoints](/guides/creating-api) - Build backend features
- [Development Tips](/guides/development) - Improve workflow
